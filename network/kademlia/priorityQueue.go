package kademlia

//
//import (
//	"container/heap"
//	"math/big"
//)
//
//type Item struct {
//	value    AddrType // The value of the item; arbitrary.
//	priority *big.Int // The priority of the item in the queue.
//	// The index is needed by update and is maintained by the heap.Interface methods.
//	index int // The index of the item in the heap.
//}
//
//// A PriorityQueue implements heap.Interface and holds Items.
//type PriorityQueue []*Item
//
//func (pq PriorityQueue) Len() int { return len(pq) }
//
//func (pq PriorityQueue) Less(i, j int) bool {
//	// We want Pop to give us the lowest, not greatest, priority so we use lowerer than here.
//	return pq[i].priority.Cmp(pq[j].priority) < 0
//}
//
//func (pq PriorityQueue) Swap(i, j int) {
//	pq[i], pq[j] = pq[j], pq[i]
//	pq[i].index = i
//	pq[j].index = j
//}
//
//func (pq *PriorityQueue) Push(x interface{}) {
//	n := len(*pq)
//	item := x.(*Item)
//	item.index = n
//	*pq = append(*pq, item)
//}
//
//func (pq *PriorityQueue) Pop() interface{} {
//	old := *pq
//	n := len(old)
//	item := old[n-1]
//	item.index = -1 // for safety
//	*pq = old[0 : n-1]
//	return item
//}
//
//// update modifies the priority and value of an Item in the queue.
//func (pq *PriorityQueue) update(item *Item, value AddrType, priority *big.Int) {
//	item.value = value
//	item.priority.Set(priority)
//	heap.Fix(pq, item.index)
//}
